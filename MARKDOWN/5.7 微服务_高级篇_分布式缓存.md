# 5.7 微服务_高级篇_分布式缓存

## 1.解决单点 Redis 的问题

### 单点 Redis 的问题

- 数据丢失问题：Redis 是内存存储，服务重启可能会丢失数据
- 并发能力问题：单节点 Redis 的并发能力虽然不错，但也无法满足如 618 这样的高并发场景
- 故障恢复问题：如果 Redis 宕机，则服务不可用，需要一种自动的故障修复手段
- 存储能力问题：Reids 基于内存，单节点能存储的数据量难以满足海量数据需求

### 基于 Redis 集群解决单机 Redis 存在的问题

- 

## 2.Redis 持久化

###  Intro

- Redis 有两种持久化方案
- RDB 持久化
- AOF 持久化

### 2.1.RDB 持久化

- 2.1.1.RDB 定义

	- RDB 全称 Redis Database Backup file（Redis 数据备份文件），也被叫做 Redis 数据快照。

简单来说就是把内存中的所有数据都记录到磁盘中。

当 Redis 实例故障重启后，从磁盘读取快照文件，恢复数据。

快照文件称为 RDB 文件，默认是保存在当前运行目录。

- 2.1.2.执行时机

	- 执行 save 命令
	- 执行 bgsave 命令
	- Redis 停机时会执行 save 命令
	- 触发 RDB 的条件（redis.conf 中的内容）

- 2.1.3 RDB的底层原理

	- 

- 2.1.4.小结

	- RDB 方式 bgsave 的基本流程？

		- fork 主进程得到一个子进程，共享内存空间
		- 子进程读取内存数据并写入新的 RDB 文件
		- 用新 RDB 文件替换旧的 RDB 文件

	- RDB 会在什么时候执行？save 60 1000 代表什么含义？

		- 默认是服务停止时
		- 代表 60 秒内至少执行 1000 次修改则触发 RDB

	- RDB 的缺点？

		- RDB 执行间隔时间长，两次 RDB 之间写入数据有丢失的风险
		- fork 子进程、压缩、写出 RDB 文件都比较耗时

### 2.2 AOF 持久化

- 2.2.1.AOF 原理

	- 

- 2.2.2.AOF 配置

	- AOF 默认是关闭的，需要修改 redis.conf 配置文件来开启 AOF
	- 

- 2.2.3.AOF 文件重写

	- 因为是记录命令，AOF 文件会比 RDB 文件大的多。
	- 而且 AOF 会记录对同一个 key 的多次写操作，但只有最后一次写操作才有意义。
	- 通过执行 bgrewriteaof 命令，可以让 AOF 文件执行重写功能，用最少的命令达到相同效果。

### 2.3.RDB 和 AOF 的区别

- 

## 3.Redis 主从

### 3.1.搭建主从结构

- 
- 3.1.0.单机安装 redis-6.2.4

	- 安装依赖
	- 解压
	- 编译
	- 修改配置
	- 启动 Redis 服务和客户端

- 3.1.1.集群结构

	- 

- 3.1.2.准备实例和配置

	- 要在同一台虚拟机开启 3 个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。
	- 1. 创建目录
	- 2. 恢复原始配置
	- 3. 拷贝配置文件到每个实例目录
	- 4. 修改每个实例的端口、工作目录
	- 5. 修改每个实例的声明 IP

- 3.1.3.启动 / 一键停止
- 3.1.4.开启主从关系

	- 

- 3.1.5.测试

	- 

- 3.1.6.小结

	- 

### 3.2.主从数据同步原理

- 3.2.1.全量同步

	- 
	- 有两个概念，可以作为判断依据

		- Replication Id

			- 简称 replid，是数据集的标记，id 一致则说明是同一数据集。
			- 每一个 master 都有唯一的 replid，slave 则会继承 master 节点的 replid

		- offset

			- 偏移量，随着记录在 repl_baklog 中的数据增多而逐渐增大。
			- slave 完成同步时也会记录当前同步的 offset。
			- 如果 slave 的 offset 小于 master 的 offset，说明 slave 数据落后于 master，需要更新。

	- 

		- 

			- 

- 3.2.2.增量同步

	- 

- 3.2.3.repl_backlog 原理

	- 

### 3.3.主从同步优化

- 提高全量同步的性能

	- 在 master 中配置 repl-diskless-sync yes 启用无磁盘复制，避免全量同步时的磁盘 IO
	- Redis 单节点上的内存占用不要太大，减少 RDB 导致的过多磁盘 IO

- 尽可能避免全量同步

	- 适当提高 repl_baklog 的大小，发现 slave 宕机时尽快实现故障恢复，尽可能避免全量同步

- 减小主节点压力同步

	- 限制一个 master 上的 slave 节点数量，如果实在是太多 slave，则可以采用 主-从-从 链式结构，减少 master 压力

- 

### 3.4.小结

- 简述全量同步和增量同步区别？

	- 全量同步：master将完整内存数据生成 RDB，发送 RDB 到 slave。后续命令则记录在 repl_baklog，逐个发送给 slave
	- 增量同步：slave 提交自己的 offset 到 master，master 获取 repl_baklog 中从 offset 之后的命令给 slave

- 什么时候执行全量同步？

	- slave 节点第一次连接 master 节点时
	- slave 节点断开时间太久，repl_baklog 中的 offset 已经被覆盖时

- 什么时候执行增量同步？

	- slave 节点断开又恢复，并且在 repl_baklog 中能找到 offset 时

## 4.Redis 哨兵

### 4.1.哨兵原理

- 4.1.1.集群结构和作用

	- 
	- 哨兵的作用

		- 监控：Sentinel 会不断检查您的 master 和 slave 是否按预期工作
		- 自动故障恢复：如果 master 故障，Sentinel 会将一个 slave 提升为 master。当故障实例恢复后也以新的 master 为主
		- 通知：Sentinel 充当 Redis 客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给 Redis 的客户端

- 4.1.2.集群监控原理

	- 

- 4.1.3.集群故障恢复原理

	- 

		- 

- 4.1.4.小结

	- Sentinel 的三个作用是什么？

		- 监控
		- 故障转移
		- 通知

	- Sentinel 如何判断一个 redis 实例是否健康？

		- 每隔 1 秒发送一次 ping 命令，如果超过一定时间没有相向则认为是主观下线
		- 如果大多数 sentinel 都认为实例主观下线，则判定服务下线

	- 故障转移步骤有哪些？

		- 首先选定一个 slave 作为新的 master，执行 slaveof no one
		- 然后让所有节点都执行 slaveof 新 master
		- 修改故障节点配置，添加 slaveof 新 master

### 4.2.搭建哨兵集群

- 4.2.1.集群结构

	- 

- 4.2.2.准备实例和配置
- 4.2.3.启动
- 4.2.4.测试

### 4.3.RedisTemplate

- 在 Sentinel 集群监管下的 Redis 主从集群，其节点会因为自动故障转移而发生变化。

Redis 的客户端必须感知这种变化，及时更新连接信息。

Spring 的 RedisTemplate 底层利用 lettuce 实现了节点的感知和自动切换。

下面，我们通过一个测试来实现 RedisTemplate 集成哨兵机制。
- 4.3.1.导入 Demo 工程
- 4.3.2.引入依赖
- 4.3.3.配置 Redis 地址
- 4.3.4.配置读写分离

## 5.Redis 分片集群

### 5.1.搭建分片集群

- 5.1.1.分片集群基本介绍

	- 主从和哨兵可以解决高可用、高并发读的问题。

但是依然有两个问题没有解决：

		- 海量数据存储问题
		- 高并发写的问题

	- 分片集群

		- 

	- 分片集群特征

		- 集群中有多个 master，每个 master 保存不同数据
		- 每个 master 都可以有多个 slave 节点
		- master 之间通过 ping 监测彼此健康状态
		- 客户端请求可以访问集群任意节点，最终都会被转发到正确节点

- 5.1.2.集群结构
- 5.1.3.准备实例和配置
- 5.1.4.一键开启所有进程
- 5.1.5.一键关闭所有进程
- 5.1.6.创建集群（Redis 5.0 之前）

	- 然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。

我们需要执行命令来创建集群，在 Redis 5.0 之前创建集群比较麻烦

Redis 5.0 之后集群管理命令都集成到了 redis-cli 中。

- 5.1.7.创建集群（Redis 5.0 之后）

### 5.2.散列插槽

- 5.2.1.插槽原理

	- 

- 5.2.2.小结

	- Redis 如何判断某个 key 应该在哪个实例？

		- 将 16384 个插槽分配到不同的实例
		- 根据 key 的有效部分计算哈希值，对 16384 取余
		- 余数作为插槽，寻找插槽所在实例即可

	- 如何将同一类数据固定的保存在同一个 Redis 实例？

		- 这一类数据使用相同的有效部分（例如 key 都以 {typeId} 为前缀）

### 5.3.集群伸缩

- 5.3.1.简述

	- 

- 5.3.2.需求分析

	- 需求：向集群中添加一个新的 master节点，并向其中存储 num = 10

		- 启动一个新的 redis 实例，端口为 7004
		- 添加 7004 到之前的集群，并作为一个 master 节点
		- 给 7004 节点分配插槽，使得 num 这个 key 可以存储到 7004 实例

	- 这里需要两个新的功能

		- 添加一个节点到集群中
		- 将部分插槽分配到新插槽

- 5.3.3.创建新的 redis 实例

	- 

- 5.3.4.添加新节点到 redis

	- 

- 5.3.5.转移插槽

	- 

		- 

			- 

				- 

### 5.4.故障转移

- 5.4.1.自动故障转移

	- 当集群中有一个 master 宕机会发生什么呢？

		- 首先是该实例与其它实例失去连接
		- 然后是疑似宕机
		- 最后是确定下线，自动提升一个 slave为新的 master
		- 当 7002 再次启动，就会变为一个 slave 节点了

- 5.4.2.手动故障转移

	- 利用 cluster failover 命令可以手动让集群中的某个 master 宕机

		- 切换到执行 cluster failover 命令的这个 slave 节点，实现无感知的数据迁移。

	- 

		- 

### 5.5.RedisTemplate 访问分片集群

- RedisTemplate 底层同样基于 lettuce 实现了分片集群的支持，而使用的步骤与哨兵模式基本一致
- 1. 引入 redis 的 starter 依赖
- 2. 配置分片集群地址
- 3. 配置读写分离

*XMind: ZEN - Trial Version*