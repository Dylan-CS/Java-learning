# 5.9 微服务_高级篇_可靠消息服务

## 1. 服务异步通信

### 

## 2. 消息可靠性

### 2.1 回顾 RabbitMQ 发送流程

- 
- 其中的每一步都可能导致消息丢失，常见的丢失原因包括

	- 发送时丢失

		- 生产者发送的消息未送达 exchange
		- 消息到达 exchange 后未到达 queue

	- MQ 宕机，queue 将消息丢失
	- consumer 接收到消息后未消费就宕机

- 针对这些问题，RabbitMQ 分别给出了解决方案：

	- 生产者确认机制
	- MQ 持久化
	- 消费者确认机制
	- 失败重试机制

### 2.2 生产者消息确认

- 2.2.1 生产者确认机制

	- 

- 2.2.2 RabbitMQ 准备工作

	- 回顾：使用 Dokcer 运行 RabbitMQ 容器
	- 回顾：使用命令开启/关闭之前的 mq 容器
	- 回顾：进入 RabbitMQ 管理平台
	- 准备工作：创建队列，并让交互机与该队列绑定
	- 使用 Dokcer 运行 RabbitMQ 容器
	- 使用命令开启/关闭之前的 mq 容器
	- 进入 RabbitMQ 管理平台
	- 创建队列，并且让 amq.topic 交互机与该队列绑定

- 2.2.3 导入项目
- 2.2.4 修改配置

	- 

- 2.2.5.定义 Return 回调
- 2.2.6.定义 ConfirmCallback

	- 消息连交换机都没有到达

ConfirmCallback 可以在发送消息时指定，因为每个业务处理 confirm 成功或失败的逻辑不一定相同。

在 publisher 服务的 cn.itcast.mq.spring.SpringAmqpTest 类中，定义一个单元测试方法

- 2.2.7.小结

	- SpringAMQP 中处理消息确认的几种情况

		- publisher-comfirm

			- 消息成功发送到 exchange，返回 ack
			- 消息发送失败，没有到达交换机，返回 nack
			- 消息发送过程中出现异常，没有收到回执

		- 消息成功发送到 exchange，但没有路由到 queue，调用 ReturnCallback

### 2.3.消息持久化

- 2.3.1.交换机持久化

	- 

- 2.3.2.队列持久化

	- 

- 2.3.3.消息持久化

	- 

### 2.4.消费者消息确认

- 2.4.1.概念

	- RabbitMQ是 阅后即焚 机制，RabbitMQ 确认消息被消费者消费后会立刻删除。
	- RabbitMQ 是通过消费者回执来确认消费者是否成功处理消息的

		- 消费者获取消息后，应该向 RabbitMQ 发送 ACK 回执，表明自己已经处理消息。

	- 设想这样的场景

这样，消息就丢失了。因此消费者返回 ACK 的时机非常重要。

		- RabbitMQ 投递消息给消费者
		- 消费者获取消息后，返回 ACK 给 RabbitMQ
		- RabbitMQ 删除消息
		- 消费者宕机，消息尚未处理

	- 而 SpringAMQP 则允许配置三种确认模式

		- manual：手动 ack，需要在业务代码结束后，调用 api 发送 ack。
		- auto：自动 ack，由 spring 监测 listener 代码是否出现异常，没有异常则返回 ack；抛出异常则返回 nack
		- none：关闭 ack，MQ 假定消费者获取消息后会成功处理，因此消息投递后立即被删除

	- 由此可知

		- none 模式下，消息投递是不可靠的，可能丢失
		- auto 模式类似事务机制，出现异常时返回 nack，消息回滚到 mq；没有异常，返回 ack
		- manual：自己根据业务情况，判断什么时候该 ack

- 2.4.2.演示 none 模式
- 2.4.3.演示 auto 模式

### 2.5.消费失败重试机制

- 2.5.1.auto 模式中存在的问题

	- 

- 2.5.2.本地重试

	- 

- 2.5.3.失败策略

	- 
	- 1. 在 consumer 服务中定义处理失败消息的交换机、队列
	- 2. 定义一个 RepublishMessageRecoverer，关联队列和交换机

### 2.6.总结

- 如何确保 RabbitMQ 消息的可靠性？

	- 开启生产者确认机制，确保生产者的消息能到达队列
	- 开启持久化功能，确保消息未消费前在队列中不会丢失
	- 开启消费者确认机制为 auto，由 spring 确认消息处理成功后完成 ack
	- 开启消费者失败重试机制，并设置 MessageRecoverer，多次重试失败后将消息投递到异常交换机，交由人工处理

## 3.死信交换机

### 3.1.初识死信交换机

- 3.1.1.什么是死信交换机

	- 什么是死信？

		- 当一个队列中的消息满足下列情况之一时，可以成为 死信（dead letter）
		- 消费者使用 basic.reject 或 basic.nack 声明消费失败，并且消息的 requeue 参数设置为 false
		- 消息是一个过期消息，超时无人消费
		- 要投递的队列消息满了，无法投递

	- 如果这个包含死信的队列配置了 dead-letter-exchange 属性，指定了一个交换机

		- 那么队列中的死信就会投递到这个交换机中，而这个交换机称为 死信交换机（Dead Letter Exchange，检查 DLX）。

	- 

		- 

- 3.1.2.利用死信交换机接收死信

	- 

- 3.1.3.小结

	- 什么样的消息会成为死信？

		- 消息被消费者 reject 或者返回 nack
		- 消息超时未消费
		- 队列满了

	- 死信交换机的使用场景是什么？

		- 如果队列绑定了死信交换机，死信会投递到死信交换机
		- 可以利用死信交换机收集所有消费者处理失败的消息（死信），交由人工处理，进一步提高消息队列的可靠性。

### 3.2.TTL

- TTL 简单介绍

	- 

- 3.2.1.接收超时死信的死信交换机

	- 

- 3.2.2.声明一个队列，并且指定 TTL

	- 

		- 

- 3.2.3.发送消息时，设定 TTL

	- 

- 3.2.4.小结

	- 消息超时的两种方式是？

		- 给队列设置 TTL 属性，进入队列后超过 TTL 时间的消息变为死信
		- 给消息设置 TTL 属性，队列接收到消息超过 TTL 时间后变为死信
		- 此外，当上述二者共存时，以时间短的 TTL 为准

	- 如何实现发送一个消息 20 秒后消费者才收到消息？

		- 给消息的目标队列指定死信交换机
		- 将消费者监听的队列绑定到死信交换机
		- 发送消息时给消息设置超时时间为 20 秒

### 3.3.延迟队列

- 3.3.1.延迟队列简单介绍

	- 

- 3.3.2.安装 DelayExchange 插件
- 3.3.3.DelayExchange 原理

	- DelayExchange 的原理是对官方原生的 Exchange 做了功能的升级

		- 将 DelayExchange 接收到的消息暂存在内存中（官方的 Exchange 是无法存储消息的）
		- 在 DelayExchange 中计时，超市后才投递消息到队列中

	- DelayExchange 需要将一个交换机声明为 delayed 类型。

当我们发送消息到 delayExchange 时，流程如下

		- 接收消息
		- 判断消息是否具备 x-delay 属性
		- 如果有 x-delay 属性，说明是延迟消息，持久化到硬盘，读取 x-delay 值，作为延迟时间
		- 返回 routing not found 结果给消息发送者
		- x-delay 时间到期后，重新投递消息到指定队列

- 3.3.4.使用 DelayExchange（控制台）

	- 

- 3.3.5.使用 DelayExchange（SpringAMQP）

	- 1. 声明 DelayExchange 交换机

		- 基于注解方式（推荐）

	- 2. 发送消息

- 3.3.6.延迟队列演示
- 3.3.7.总结

	- 延迟队列插件的使用步骤包括哪些？

		- 声明一个交换机，添加 delayed 属性为 true
		- 发送消息时，添加 x-delay 头，值为超时时间

## 4.惰性队列

### 4.1.消息堆积问题

- 

### 4.2.惰性队列

- 惰性队列的特征如下

	- 接收到消息后直接存入磁盘而非内存
	- 消费者要消费消息时才会从磁盘中读取并加载到内存
	- 支持数百万条的消息存储

- 4.2.1.基于命令行设置 lazy-queue

	- 

- 4.2.2.基于 @Bean 声明 lazy-queue

	- 

- 4.2.3.基于 @RabbitListener 声明 LazyQueue

	- 

- 4.2.4.惰性队列演示
- 4.2.5.小结

	- 消息堆积问题的解决方案？

		- 队列上绑定多个消费者，提高消费速度
		- 使用惰性队列，可以再 mq 中保存更多消息

	- 惰性队列的优点有哪些？

		- 基于磁盘存储，消息上限高
		- 没有间歇性的 page-out，性能比较稳定

	- 惰性队列的缺点有哪些？

		- 基于磁盘存储，消息时效性会降低
		- 性能受限于磁盘的 IO

## 5.MQ 集群

### 5.1.基本概念

- 5.1.1.集群分类

	- RabbitMQ 的集群有两种模式

		- 普通集群

			- 是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。

		- 镜像集群

			- 是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。
			- 镜像集群虽然支持主从，但主从同步并不是强一致的，某些情况下可能有数据丢失的风险。

		- 仲裁队列

			- 其是在因此在 RabbitMQ 的 3.8 版本以后推出的新功能
			- 该功能是用来代替镜像集群的，其底层采用 Raft 协议确保主从的数据一致性。

- 5.1.2.普通集群

	- 

- 5.1.3.镜像集群

	- 

- 5.1.4.仲裁队列

	- 

### 5.2.集群部署

- 5.2.1.集群分类

	- 

- 5.2.2.获取 cookie

	- 

- 5.2.3.准备集群部署

	- 

- 5.2.4.启动集群

	- 

- 5.2.5.测试数据共享

	- 在 mq1 中新建一个队列
	- 创建完毕
	- 发现三个节点都可以看到创建的队列（因为普通集群中的队列的元信息是互通的嘛）
	- 在 mq1 中的 simple.queue 中尝试发送消息
	- 发现 mq2 中有数据，在 mq2 中尝试获取消息

- 5.2.6.测试可用性

### 5.3.镜像集群部署

- 
- 5.3.1.镜像模式的特征

	- 

- 5.3.2.镜像模式的配置

	- 
	- 1. exactly 模式

		- 

	- 2. all 模式

		- 

	- 3. nodes 模式

		- 

- 5.3.3.测试数据共享

	- 

		- 

- 5.3.4.测试高可用

	- 

### 5.4.仲裁队列部署

- 从 RabbitMQ 3.8 版本开始，引入了新的仲裁队列，他具备与镜像队里类似的功能，但使用更加方便。
- 5.4.1.添加仲裁队列（控制台）

	- 

- 5.4.2.Java 代码创建仲裁队列

	- 

- 5.4.3.SpringAMQP 连接 MQ 集群（配置文件）

	- 

*XMind: ZEN - Trial Version*