# 5.6 微服务_高级篇_分布式事务

## 1. 分布式事务问题

### 1.1 本地事务

- 

### 1. 2 分布式事务

- 在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务，要保证所有分支事务最终状态一致，这样的事务就是分布式事务。即不是在单个服务或单个数据库架构下产生的事务

	- 

- 例如

	- 跨数据源的分布式事务
	- 跨服务的分布式事务
	- 综合情况

### 1.3 分布式问题

- 经过测试发现：当库存不足时，如果余额已经扣减，并不会回滚，这就是出现了分布式事务问题。

## 2. 理论基础

### 2.1 CAP 定理

- 2.1.1 概述

	- 1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。

		- Consistency（一致性）
		- Availability（可用性）
		- Partition tolerance （分区容错性）

	- Eric Brewer 说，分布式系统无法同时满足这三个指标。这个结论就叫做 CAP 定理。

- 2.1.2 一致性

	- Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。

- 2.1.3 可用性

	- Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。

- 2.1.4 分区容错

	- Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。
	- Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务

- 2.1.5 矛盾

	- 

### 2.2 Base理论

- BASE 理论是对 CAP 的一种解决思路，包含三个思想

	- Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。
	- Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。
	- Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。

### 2.3 解决分布式事务的思路

- 

### 2.4 小结

- 简述 CAP 定理内容

	- 分布式系统节点通过网络连接，一定会出现分区问题（P）
	- 当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足

- 思考：elasticsearch 集群是 CP 还是 AP？

	- ES 集群出现分区时，故障节点会被剔除集群，数据分片会重新分配到其它节点，保证数据一致。
	- 因此是低可用性，高一致性，属于 CP

- 简述 BASE 理论三个思想

	- 基本可用、软状态、最终一致

- 解决分布式事务的思想和模型

	- 全局事务：整个分布式事务
	- 分支事务：分布式事务中包含的每个子系统的事务
	- 最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据
	- 强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚

## 3. 初始 Seta

### 3.1 简述 Seta

- Seata 是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。

致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。

官网地址：http://seata.io/

该网站的文档、播客中提供了大量的使用说明、源码分析。

### 3.2 Seta 架构

- Seata 事务管理中有三个重要的角色

	- TC （Transaction Coordinator）- 事务协调者

		- 维护全局和分支事务的状态，协调全局事务提交或回滚。

	- TM （Transaction Manager）- 事务管理器

		- 定义全局事务的范围、开始全局事务、提交或回滚全局事务。

	- RM （Resource Manager）- 资源管理器

		- 管理分支事务处理的资源，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。

- 整体架构

	- 

- Seata 基于上述架构提供了四种不同的分布式事务解决方案：

	- XA 模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入
	- TCC 模式：最终一致的分阶段事务模式，有业务侵入
	- AT 模式：最终一致的分阶段事务模式，无业务侵入，也是 Seata 的默认模式
	- SAGA 模式：长事务模式，有业务侵入

### 3.3 部署 TC 服务

- 3.3.1下载

	- 首先我们要下载 seata-server 包

下载地址：http://seata.io/zh-cn/blog/download.html

当然，课前资料也准备好了

- 3.3.2 解压查看基本目录
- 3.3.3 修改配置文件信息

	- 修改 conf 目录下的 registry.conf 文件

- 3.3.4 在 Nacos 页面中添加配置

	- 特别注意：为了让 tc 服务的集群可以共享配置，我们选择了 nacos 作为统一配置中心。
	- 因此服务端配置文件 seataServer.properties 文件需要在 nacos 中配好。
	- GROUP 是 DEFAULT_GROUP

- 3.3.5 创建数据库表

	- 特别注意：tc 服务在管理分布式事务时，需要记录事务相关数据到数据库中，你需要提前创建好这些表。
	- 新建一个名为 seata 的数据库，运行课前资料提供的 sql 文件

- 3.3.6 启动 TC 服务

	- 进入 bin 目录，运行其中的 seata-server.bat 即可

### 3.4 微服务集成 Seata

- 3.4.1.引入依赖

	- 首先，在 order-service 中引入依赖

- 3.4.5 配置 TC 地址

	- 在 order-service 中的 application.yml 中，配置 TC 服务信息，通过注册中心 nacos，结合服务名称获取 TC 地址

### 3.5.小结

- nacos 服务名称组成包括？

	- namespace + group + serviceName + cluster

- seata 客户端获取 tc 的 cluster 名称方式？

	- 以 tx-group-service 的值为 key 到 vgroupMapping 中查找

## 4. 动手实践

### 4.1 XA 模式

- 4.1.1 简单介绍

	- XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准
	- XA 规范 描述了全局的 TM 与局部的 RM 之间的接口
	- 几乎所有主流的数据库都对 XA 规范 提供了支持。

- 4.1.2 两阶段提交

	- 

- 4.1.3 Seata 的 XA 模型

	- 
	- RM 一阶段的工作

		- 注册分支事务到 TC
		- 执行分支业务 sql 但不提交
		- 报告执行状态到 TC

	- TC 二阶段的工作

		- TC 检测各分支事务执行状态
		- a.如果都成功，通知所有 RM 提交事务
		- b.如果有失败，通知所有 RM 回滚事务

	- RM 二阶段的工作

		- 接收 TC 指令，提交或回滚事务

- 4.1.4 优缺点

	- XA 模式的优点是什么？

		- 事务的强一致性，满足 ACID 原则。
		- 常用数据库都支持，实现简单，并且没有代码侵入

	- XA 模式的缺点是什么？

		- 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差
		- 依赖关系型数据库实现事务

- 4.1.5 实现 XA 模式

	- 1. 修改 application.yml 文件（每个参与事务的微服务），开启 XA 模式
	- 2. 给发起全局事务的入口方法添加 @GlobalTransactional 注解
	- 3. 重启服务并测试

### 4.2 AT 模式

- 4.2.1 Seata 的 AT 模型

	- 
	- 阶段一 RM 的工作

		- 注册分支事务
		- 记录 undo-log（数据快照）
		- 执行业务 sql 并提交
		- 报告事务状态

	- 阶段二提交时 RM 的工作

		- 删除 undo-log 即可

	- 阶段二回滚时 RM 的工作

		- 根据 undo-log 恢复数据到更新前

- 4.2.2 流程梳理

	- 

		- 

			- 

				- 

- 4.2.3 AT 与 XA 的区别

	- XA 模式一阶段不提交事务，锁定资源；AT 模式一阶段直接提交，不锁定资源。
	- XA 模式依赖数据库机制实现回滚；AT 模式利用数据快照实现数据回滚。
	- XA 模式强一致；AT模式最终一致

- 4.2.4 脏写问题

	- 

		- 

			- 

- 4.2.5 优缺点

	- AT 模式的优点

		- 没有代码侵入，框架自动完成回滚和提交
		- 利用全局锁实现读写隔离
		- 一阶段完成直接提交事务，释放数据库资源，性能比较好

	- AT 模式的缺点

		- 两阶段之间属于软状态，属于最终一致
		- 框架的快照功能会影响性能，但比 XA 模式要好很多

- 4.2.6 实现 AT 模式

	- AT 模式中的快照生成、回滚等动作都是由框架自动完成，没有任何代码侵入，因此实现非常简单。

只不过，AT 模式需要一个表来记录全局锁、另一张表来记录数据快照 undo_log。
	- 1. 导入数据库表，记录全局锁
	- 2. 修改 application.yml 文件，将事务模式修改为 AT 模式即可
	- 3. 重启服务并测试

### 4.3 TCC 模式

- 4.3.1 简述

	- TCC 模式与 AT 模式非常相似，每阶段都是独立事务。

不同的是 TCC 通过人工编码来实现数据恢复。

需要实现三个方法

		- Try：资源的检测和预留；
		- Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。
		- Cancel：预留资源释放，可以理解为 try 的反向操作。

- 4.3.2 流程分析

	- 

		- 

- 4.3.3 Seata 的 TCC 模型

	- 

- 4.3.4 优缺点

	- TCC 的优点是什么？

		- 一阶段完成直接提交事务，释放数据库资源，性能好
		- 相比 AT 模型，无需生成快照，无需使用全局锁，性能最强
		- 不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库

	- TCC 的缺点是什么？

		- 有代码侵入，需要人为编写 try、Confirm 和 Cancel 接口，太麻烦
		- 软状态，事务是最终一致
		- 需要考虑 Confirm 和 Cancel 的失败情况，做好幂等处理

- 4.3.5 事务悬挂和空回滚

	- 1. 空回滚

		- 

	- 2. 业务悬挂

		- 对于已经空回滚的业务，之前被阻塞的 try 操作恢复，继续执行 try，就永远不可能 confirm 或 cancel，事务一直处于中间状态

这就是业务悬挂。

执行 try 操作时，应当判断 cancel 是否已经执行过了，如果已经执行，应当阻止空回滚后的 try 操作，避免悬挂

- 4.3.6 实现 TCC 模式

	- 案例

		- 改造 account-service 服务，利用 TCC 实现分布式事务

	- 需求

		- 修改 account-service，编写 try、confirm、cancel 逻辑
		- try 业务：添加冻结金额，扣减可用金额
		- confirm 业务：删除冻结金额
		- cancel 业务：删除冻结金额，恢复可用金额
		- 保证 confirm、cancel 接口的幂等性
		- 允许空回滚
		- 拒绝业务悬挂

	- 解决空回滚和业务悬挂问题，必须要记录当前事务状态，是在 try、还是 cancel。

		- 思路分析
		- 声明 TCC 接口
		- 编写实现类
		- 修改 Controller 类

### 4.4  SAGA 模式

- 4.4.1 简述

	- Saga 模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。

其理论基础是 Hector & Kenneth 在 1987 年发表的论文 Sagas。

Seata 官网对于 Saga 的指南：https://seata.io/zh-cn/docs/user/saga.html

- 4.4.2 原理

	- 在 Saga 模式下

		- 分布式事务内有多个参与者
		- 每一个参与者都是一个冲正补偿服务
		- 需要用户根据业务场景实现其正向操作和逆向回滚操作。

	- 分布式事务执行过程中，依次执行各参与者的正向操作

		- 如果所有正向操作均执行成功
		- 那么分布式事务提交
		- 如果任何一个正向操作执行失败
		- 那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。

	- Saga 也分为两个阶段

		- 一阶段：直接提交本地事务
		- 二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚

- 4.4.3 优缺点

	- 优点

		- 事务参与者可以基于事件驱动实现异步调用，吞吐高
		- 一阶段直接提交事务，无锁，性能好
		- 不用编写 TCC 中的三个阶段，实现简单

	- 缺点

		- 软状态持续时间不确定，时效性差
		- 没有锁，没有事务隔离，会有脏写

### 4.5 四种模式对比

- 

## 5. 高可用

### 5.1 高可用架构模型

- 

### 5.2 实现高可用

- 具体实现请参考课前资料提供的文档 seata的部署和集成.md 中的第三章节
- 5.2.1 模拟异地容灾的 TC 集群
- 5.2.2 将事务组映射配置到 nacos
- 5.2.3 微服务读取 nacos 配置

*XMind: ZEN - Trial Version*